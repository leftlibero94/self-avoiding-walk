{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# How To Avoid Oneself: A Monte-Carlo Study"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "#importing the libraries and modules we will need, run this first\n",
    "\n",
    "import numpy as np\n",
    "from numpy.random import randint\n",
    "import matplotlib.pyplot as plt\n",
    "import time\n",
    "from matplotlib.ticker import PercentFormatter\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The Drunkard's Walk: A Simple 2D Random Walk "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A **random walk** (or more evocatively, a drunkard's walk) is a common mathematical model and thought experiment that goes as follows: a man walks out of his favourite pub to go home, but with his navigation faculties significantly impaired. At every step he takes, he has a roughly equal probability of walking North, East, South or West. After a long enough time, where are we likely to find him, and what is the path he has followed? It turns out that in $2D$, the probability distribution for the straight line distanced covered by the man can be described by a Gaussian (normal) curve, specifically the Raleigh distribution,\n",
    "\\begin{equation}\n",
    "    P(r)=\\frac{2r}{N}e^{-r^2/N}\n",
    "\\end{equation}    \n",
    "\n",
    "and the distance ($R$) varies with respect to the number of steps ($N$) as\n",
    "\\begin{equation}\n",
    "    R^2 \\propto N\n",
    "\\end{equation}\n",
    "\n",
    "While the model seems laughably primitive, it was used by Albert Einstein to explain Brownian motion of a colloidal particle and by Louis Bachelier to model the stock prices of French government bonds around the early 20th century, and still serves as a very good statistical model for diffusion phenomena and for the Black-Scholes formula for options pricing (as two examples). Let us now see what a walk like that would look like by writing a simple program, starting from the origin $(0,0)$ and using a random number generator that churns out an integer from $1$ to $4$ with equal probability, each number corresponding to motion in one of the four directions on a $2D$ plane. [Note: This is far from the most elegant/optimal way to simulate a RW, but it may be the most intuitive/instructive, and that is our goal here.]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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7m3duuFXN+iu8+4qejuOPvpo3XjjjWpoaNDHPvYx7bXXXn0ef8973qO2tjbNnTtXN910k44++uidj3V1dWn79u1auHCh6uvr9eqrr2rhwoU6//zz9cgjj/SZzze/+U2ddNJJ+tGPfqQdO3aoqalJc+bM0Xvf+15dffXVkqQDDzyw6P0rShC7e5ekvYatCAAoGw++/OCAw9GD2eE79OBLD5akHTfddJPOOeccXXLJJTIzHXrooZozZ46uvPJK7b777tpll110+OGHS5Kam5t1/PHH73xufX29vpv1ncpt27Zp2rRpOvHEE7V27Vo1NDTsfGzffffVXXf1/SBRV1en+vr6PvMsNn5ZCwCQU3dPfudJR7r3nK/DDz9cq1ev1vLlyzV//ny5u772ta+ppaVFb7311rDP/9GPfqSjjjpKu+22m6qrq3XiiSdKkl566aU+9WbNmlWS9g+HIAYA5FRTnd9PY9ZUle6nNHfZZRedddZZ+s53vqNVq1bpBz/4gV5++WXdcsstQz7vvvvu08UXX6wTTjhBd999t5588kndd1/4zamtW7f2qbvPPvuUrP1DIYgBADnNev8sVdjIYqLCKjTroLHbo7z00kv17ne/W2vWrBmy3t13363jjjtON998s84880wdd9xx2nPPPXPWjfVToAQxACCnBScsGPFe7q5Vu2rBCQtK0o5c/9Vo48aNevPNN3fuxU6aNEnSwL3c7u5u7bLLLn3K2traRrzsSZMmDZhnsfH/iAEAOR079ViddfBZWrZm2ZDnf2uqanT2wWdrxn4zStKOww47TLNnz9bpp5+uKVOmqLOzU9dff71qa2v16U9/WpLU0NCgmpoa3Xrrrdpjjz1UXV2tlpYWnXbaabriiiu0cOFCHXfccXrooYf02GOPjXjZhxxyiB555BE98sgj2muvvTRt2rQBV20Xij1iAEBOZqbF5yzW7ENmq666bsBh6gqrUG11rWYfMluLz1lcskO7X/7yl9XR0aG///u/1+mnn66rr75a06dP14oVKzRt2jRJ0q677qrvf//7WrlypT70oQ9pxozwoeCyyy7TggUL9O1vf1vnnnuuOjs7dfvtt4942VdddZUOPfRQXXDBBZoxY4YeeOCBovfPxuI3QvtraWnx9vb2MV9uOTALPxWZBmnqC1CuVq9erUMPPbSgebi7nl7/tK7/P9froZcf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\n",
      "text/plain": [
       "<Figure size 576x576 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "x,y=0,0\n",
    "h=1\n",
    "X,Y=[x],[y]\n",
    "n=100\n",
    "\n",
    "for i in range(n):\n",
    "    a=randint(1,5)\n",
    "    if a==1:\n",
    "        x+=h\n",
    "        X.append(x)\n",
    "        Y.append(y)\n",
    "    elif a==2:\n",
    "        x-=h\n",
    "        X.append(x)\n",
    "        Y.append(y)\n",
    "    elif a==3:\n",
    "        y+=h\n",
    "        X.append(x)\n",
    "        Y.append(y)\n",
    "    elif a==4:\n",
    "        y-=h\n",
    "        X.append(x)\n",
    "        Y.append(y)\n",
    "\n",
    "plt.figure(figsize = (8, 8))\n",
    "plt.plot(X, Y, 'bo-', linewidth = 1)\n",
    "plt.plot(0, 0, 'go', ms = 12, label = 'Start')\n",
    "plt.plot(X[-1], Y[-1], 'ro', ms = 12, label = 'End')\n",
    "plt.axis('equal')\n",
    "plt.legend(fontsize=15)\n",
    "plt.title('Figure 1: Simple random walk of length ' + str(n), fontsize=14, fontweight='bold')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## You Can Never Go Back: A Non-Reversing Random Walk"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Making things a little more complicated for ourselves, let us now try to model a walk where you can move in any direction you want, except for turning around immediately or taking a step backward: this is called a **non-reversing random walk**. This is slightly more complicated, as at every step, the walker must have a memory of his previous location, like the flip-flop element in electronic circuits. This is unlike the simple random walk model, which is what is called a Markov chain process - every step is independent, and has no connection or causal link with the previous process. The non-reversing walk is not a Markov chain process, it has a memory that goes back one iteration. How to model this?\n",
    "\n",
    "One way is using something called **rejection sampling**. You still go the random walk way, but every time your algorithm generates a movement that is not allowed (i.e. left, when you have just moved right, or up when you have just moved down, etc.), you reject that iteration and run the loop again. In this way, the only movements that show up in your actual working program are the ones that pass this test. However, the problem is attrition: you lose computer power, time and loop iterations doing this, and if you wanted a path of 50 iterations (say), you may not eventually get 50 steps, because of the (illegal!) loops you discarded along the way. Here, we have grouped (up,down) (corresponding to $(1,4)$) and (left,right) (corresponding to $(2,3)$) as complementary moves that are not allowed in successive iterations, as their sums add up to $5$ - whenever this happens, a loop is discarded, and we start again.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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b3mLzGzLc2vXrtUHP/hB7bPPPurs7NSee+6pD3zgA3rppZdGzOuKK67QRz7yEU2bNk0HHHCAjjrqKC1dulTXXHPNlnleffXVdVlGxI8rrwAAZOzyX16uoY1DFdUd2jiky395uW487caax3HQQQfpG9/4hrq6unTCCSfola985bDnX/WqV6m3t1dz5szRN7/5TR100EFbnhscHNSmTZs0b948TZs2Tc8884zmzZun008/Xffcc8+w+Xz1q1/VkUceqWuvvVabN29WT0+PTj31VO2111767Gc/K0l6zWteU/PlQ2sgeQUAIGN3PnmnNvvmiupu9s2684k76xLHN7/5TZ188sk655xzZGbad999deqpp+rCCy/UDjvsoG233VYHHnigJGm//fbTYYcdtuW106ZN07e+9a0t0xs3btSee+6pI444QsuXL1dXV9eW53bbbTfdeOPw5Hvq1KmaNm3asHkCpTBsAACAjA1tqOyq65b6FV6lrdaBBx6oxx57TIsWLdL5558vd9cXv/hF5XI5rVmzZszXX3vttXrjG9+o7bbbTpMmTdIRRxwhSXriiSeG1Tv++OPrEj8mBpJXAAAyNmVSdTcsTemo3w1O2267rU488URdeeWVevTRR/Wd73xHTz75pL773e+O+rrbbrtNZ511lg4//HDdfPPNuu+++3TbbbdJktatWzes7q677lq3+NH6SF4BAMjY8a89Xm1W2Sm5zdp0/MzGXbl8z3veo1e84hVatmzZqPVuvvlmHXroobrqqqv0jne8Q4ceeqh23nnnknX5iVdsDZJXAAAydsHhF1R8NXVyx2RdcPgFdYlj1apVI8pWr16tF198ccvV0m222UbSyKupQ0ND2nbbbYeV9fb2Vtz2NttsM2KeQCncsAUAQMYOmXGITtznRN2x7I5Rx7NO6Ziik/Y5SbNePasucRxwwAGaPXu2jjvuOE2fPl0DAwO67LLL1NnZqbPPPluS1NXVpSlTpuiaa67RjjvuqEmTJimXy+nYY4/VBz7wAc2bN0+HHnqo7rrrLv34xz+uuO3Xve51uueee3TPPffola98pfbcc88R33YASFx5BQAgc2amBScv0OzXzdbUSVNHDCFoszZ1TurU7NfN1oKTF9TtY/fPfe5z6u/v14c//GEdd9xx+uxnP6v9999fS5Ys0Z577ilJmjx5sr797W9r6dKl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\n",
      "text/plain": [
       "<Figure size 576x576 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "x,y=0,0\n",
    "h=1\n",
    "X,Y=[x],[y]\n",
    "n=100\n",
    "steps=0\n",
    "a1=randint(1,5)\n",
    "for i in range(n):\n",
    "    a=randint(1,5)\n",
    "    if a+a1==5: continue\n",
    "    if a==1:\n",
    "        x+=h\n",
    "        X.append(x)\n",
    "        Y.append(y)\n",
    "    elif a==4:\n",
    "        x-=h\n",
    "        X.append(x)\n",
    "        Y.append(y)\n",
    "    elif a==2:\n",
    "        y+=h\n",
    "        X.append(x)\n",
    "        Y.append(y)\n",
    "    elif a==3:\n",
    "        y-=h\n",
    "        X.append(x)\n",
    "        Y.append(y)\n",
    "    a1=a\n",
    "    steps+=1\n",
    "\n",
    "plt.figure(figsize = (8, 8))\n",
    "plt.plot(X, Y, 'bo-', linewidth = 1)\n",
    "plt.plot(0, 0, 'go', ms = 12, label = 'Start')\n",
    "plt.plot(X[-1], Y[-1], 'ro', ms = 12, label = 'End')\n",
    "plt.axis('equal')\n",
    "plt.legend(fontsize=15)\n",
    "plt.title('Figure 2: Non-reversing RW of length ' + str(steps) + ' - attempted length ' + str(n) + ' (rejection sampling)', fontsize=14, fontweight='bold')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A better (and more efficient) way of simulating a non-reversing walk is by restricting the sample space of feasible movements for our walker in the first place - this incorporates the memory of the previous position in a less attritional way. For our next program, before we generate the random number that tells our walker which way to go, we first cross-reference with our memory variable, which stores the last known position, and restrict the space of possible movements, **BEFORE** using the random number generator. Only then do we generate the next step for our walk. This way, we always end up with the path of the length we want.  \n",
    "\n",
    "[Note: One thing to note is the qualitative difference between a simple RW and a non-reversing RW - in the first case, there are many open ends, but in a non-reversing walk, it's all closed loops. We should expect this as the only way an open end is generated is if the walker goes forward and then comes back along the same path and then goes elsewhere - this is specifically prohibited for a non-reversing walk. The only way it can get out of a hole is by creating a closed loop.]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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O07XXHONtm/frnw+r7PPPluvetWr9PGPf1yS9OpXv7rqy2dZXMSfrEKh4P39/bXuBoAI5PMhLMt1dUnVvJyYVZ3YrF27Vocccsi0fnf2pbMnPHoeMX37bD33seemVWs8Dz74oM4880z96le/kpnpkEMO0dlnn60PfvCDO75a8+GHH9Zhhx2mH/7whzr++OPHnNfWrVt133336dhjj9XAwIA6OzslhSPoN7zhDXrggQdGTF8oFPTa1752UkfOE61rM1vj7oXydk5xA4jShg2V2wcGJLPqDZXCebz6kIa2TO7oecf0kzzanqrXve51Wrt2rVatWqXFixfL3fXpT39ahUJBzz038Q7BNddcoze+8Y3aZZdd1N7ermOPPVaS9Pjjj4+YbsGCBan0fyIENIAoJQcwo3R1Se7VG7q6plYfUkf71G6S6mhL76aqnXfeWaeffrq+/OUv69FHH9XXvvY1/eIXv9CVV1457u/dfPPNuuCCC3TMMcfohhtu0L333qubb75ZkvTCCy+MmHbvvfdOrf/jIaABRGnZMimXG9mWy4X2eqzTSBa8ZoFabHLx0WItWnBgdkeg73rXu/Syl71M69atG3e6G264QUcddZSuuOIKvfWtb9VRRx2lPffcs+K0tfpKVAIaQJS6u6Xe3uEj3K6uMF7tG7eyqtNIlhyzZNJHxbPaZmnJMUtS6Uel/xL11FNP6Zlnntlx1LvTTjtJGn1UPDQ0pJ133nlEW98Ubt/faaedRs2z2riLG0C0urvDYJbuDVtZ1WkUR849UqcfdLpuXXfruNeXO9o6dMZBZ2j+vvNT6cdhhx2mhQsX6pRTTtGcOXM0MDCgyy67TLlcThdeeKEkqbOzUx0dHbr66qu1++67q729XYVCQSeffLLe/e53a9myZTrqqKN0++2366677pp07YMPPlh33HGH7rjjDr385S/XAQccMOou8pniCBoAMCVmpuVnLtfCgxdqdvvsUae7W6xFufacFh68UMvPXJ7aKeJPfOITWr9+vd773vfqlFNO0cc//nHNmzdPq1ev1gEHHCBJmjVrlv793/9da9as0Zve9CbNnx92Fi666CItWbJEX/ziF3XWWWdpYGBA11577aRrX3zxxTrkkEN07rnnav78+brtttuqvnz8mRWA6JmFG7oapU4MZvJnVkXurvs33a/L/u9luv0Xt2to65A62jq04MAF+uAxH9T8uekcOdeb6f6ZFae4AQDTYmY6cu6Ruv6c62vdlYbEKW4AACJEQAMAECECGgCACBHQAABEiIAGACBCBDQAABEioAEAiBABDQBAhAhoAEDd+tSnPiUzqzisWLFiRvN+7rnnZGa66qqrqtPZKeKbxAAA0+MurV4tXXaZdPvt0tCQ1NEhLVggffCD0vz54ftTU7b77rvru9/97qj2v/iLv0i9dpoIaADA1G3ZIl1wgbRqlfTCC9L27aF9cFC66aYQ2KefLi1fLrW3p9qVtrY2HX300anWqAVOcQMApsZ9OJwHB4fDuWj7dun556Vbbw3T1fA/kKxfv15mpuuvv14XXXSRdt99d+2333765Cc/qe1l/b7pppt04IEHqqOjQ8cdd5zWrVtXo14HBDQAYGpWr5Zuuy2E83iGhsJ099+fepe2bt06aij1oQ99SLvssotuvPFGveMd79A///M/68Ybb9zx/E9/+lP97d/+rV7/+tdr5cqVOuOMM3Tuueem3u/xcIobADA1l18ewncyhobC9N/6Vmrd+cMf/qD2CqfRf/WrX+14fNxxx+nyyy+XJJ188sn67ne/q5UrV+4I4c9+9rM68MADdf3118vM9Na3vlUvvviiLr744tT6PZHUA9rMWiX1S9ro7qelXQ8AkLJvf3v0ae2xbN8epk/R7rvvrjvvvHNU+7777qtNmzZJkk455ZQRzx166KHasGHDjvHVq1frvPPOk5Xc1HbWWWfVNKCzOMX9PklrM6gDTElfn5TPSy0t4WdfX33XyVLW605qjDoNY7JHz9Odfora2tpUKBRGDTvttNOOafbYY48Rv7PTTjvphRde2DH+29/+VnPmzBkxTfl41lI9gjaz/SQtkLRM0gfSrAVMRV+f1NMzfAltYCCMS1J3d/3VyVKjrbtGfI1S19Ex8fXn8ukjt88++2jz5s0j2srHs5b2EfS/SfqQpEmeCwGysXTp6O3L4GBor8c6WWq0ddeIr1HqFiwIp08mo6UlTB+5+fPna9WqVfKSO85XrlxZwx6leARtZqdJ2uzua8zs+HGm65HUI0mdnZ1pdQcYoeTS0wgDA5l8r8KY9etBo627seZXz69R6pYsCX/n/PzzE087a1aYPkVbt27VvffeO6p9//33n/Q8PvzhD+uoo47Sueeeq3e96116+OGHdeWVV1azm1OW5hH0X0k6w8zWS7pO0glmNup719y9190L7l7Ya6+9UuwOMGysfcGurvAnm9UaurqmVr8eNNq6G2t+9fwape7II8OXkEx06rqjQzrjjPCNYil65plndMwxx4wavvGNb0x6HoVCQdddd50eeOABnXnmmbrlllv0rRTvPJ8Ud099kHS8pP+YaLojjjjCgSysWOGey42MhFwutNdjnSw12rprxNdoMh599NGZzeCll9zPO8999mz3lpaRK7ClJazE884L0zW5ida1pH6vlJ2VGqs9ENCI0YoV7l1d4VPQ1ZXeBjmrOlnKet2Z8RpV24wD2t19+3b3++5zP+ec4aCePdv93HPdV6+e+fwbxHQD2sJzcSgUCt7f31/rbqDJmGXzTYRZ1clSoy1Toy3PeNauXatDDjmk1t1oChOtazNb4+6F8na+6hMAgAgR0AAARIiABgAgQgQ0ADSpmO5BalQzWccENAA0ofb2dg2l/B3ZkIaGhir+p63JIKABoAnNmTNHGzdu1ODgIEfSKXB3DQ4OauPGjdP+pxv8P2gAaEK77babJGnTpk3asmVLjXvTmNrb27X33nvvWNdTRUADQJPabbfdph0eSB+nuAEAiBABDQBAhAhoAAAiREADABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaExKX5+Uz0stLeFnX1991ymtJWWzTGnXyVLW6y7t98PixVJb8sXHbW1hPC2N+FlCStw9muGII45wxGfFCvdczl0aHnK50F6PdbKsleUyZaXR1t2iRSNrFIdFi6pbx73x1h2qQ1K/V8hE84j+zVihUPD+/v5adwNl8nlpYGB0e1eXtH59/dXJslaWy5SVRlt3bW3Stm2j21tbpa1bq1dHarx1h+owszXuXhjVTkBjIi0tYR+8GZhJ27dXb35jrbtq18lSM70fGk09v+8a2VgBzTVoTKizs3J7V1elE4PTH7q6sqkzXq2xlnW6xppftetkqdHeD62tleu0tmb3vstq3dXz+64ZEdCY0LJlUi43si2XC+31WCfLWlkuU1Yabd319EytfSYabd0hZZUuTNdq4CaxeK1Y4d7VFfbPu7rSu9mkWMcs3TpZ1spq3WUp63WXdp1Fi9xbW8Nr1Nqazg1iRbzvUE7cJIZqMOP643Sx7uLXiK9RIy5To+EaNAAAdYSABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMAECECGgCACBHQAABEiIAGACBCqQa0me1vZj80s7Vm9oiZvS/NegAANIq0j6C3Slri7odIOlrSu83s0JRrIgV9fVI+Hx7n82E8zTotLenWybIW6y5+Wb1GWWrEZWo67p7ZIOlWSSeP9fwRRxzhiM+KFe65nLs0PORyob0e62RZq9HqZF0rC422PO6NuUyNTFK/V8hEC8+lz8zyku6R9Fp3f7bSNIVCwfv7+zPpDyYvn5cGBka3d3VJ69fXX50sazVanaxrZaHRlkdqzGVqZGa2xt0Lo9qzCGgz20XSjyQtc/eVZc/1SOqRpM7OziMGKr2rUFMtLWEfvBmYSdu3V29+Y627rOpkqdrLlJWsXqMsNeIyNbKxAjr1u7jNrF3STZL6ysNZkty9190L7l7Ya6+90u4OpqGzs3J7V1fpCbSZD11d2dQZr9ZYyzpdY80vqzr1vO6yktVrlKVGXKZmlPZd3CbpSklr3f0LadZCepYtk3K5kW25XGivxzpZ1mq0OlnXykKjLY/UmMvUlCpdmK7WIOlYSS7pQUk/S4a3jTU9N4nFa8UK964ud7PwM62bTbKqU1pLymaZGqVO1rWy0GjL496Yy9SoVOubxCaDm8RQC2bZXL9ttDpZ18pCoy2P1JjL1Ghqdg0aAABMHQENAECECGgAACJEQAMAECECGgCACBHQAABEiIAGACBCBDQAABEioAEAiBABDQBAhAhoAAAiREADABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaDStxYultrbwuK0tjKehr0/K58PjfD6MpyGr5ZGkk06SzMJjszCehuIymTXGa1Raq6Ul3VpZLhNS4u7RDEcccYQDWVi0yF0aPSxaVN06K1a453Ija+Ryob2asloed/cTT6xc68QTq1un0V6jLGtluUyYOUn9XiETLTwXh0Kh4P39/bXuBppAW5u0bdvo9tZWaevW6tXJ56WBgdHtXV3S+vXVq5PV8kjDR86VVHNz0mivUZa1slwmzJyZrXH3Qnl7Wy06A9RapQ1/sX28AKqWDRuqO79aL09RFrXGWtbpGuu1qPZrNN48Bwbq832HdHENGk2ptXXs9sonVqc3dHVVrtPZWZ/LM9ERcjXrjLdM1TTWa1Ht12i8eXZ11ef7DukioNGUenqm1j5dy5ZJudzItlwutFdTVssjSSeeOLX26Wq01yjLWlkuE1JU6cJ0rQZuEkOWFi1yb20NxxytrencUOUebszp6nI3Cz/TulEnq+VxH32jWLVvECvK+jWS0n2NsqyV1fsOMyduEgMqM6vuzU21luXyZFWr0epkXQtxG+smMU5xAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMAECECGgCACBHQAABEiIAGACBCBDQAABEioAEAiBABDQBAhAhoRMHddd+T9+mcG87R7Etnq+WSFs2+dLbOveFcrd64WjH933IAyEJbrTsAbNm2RRfccoFWPbZKL2x9Qdt9uyRpcMugblp7k27/xe06/aDTtfzM5Wpvba9xbwEgGxxBo6bcfUc4D24Z3BHORdt9u57f8rxuXXerLrjlAo6kATSN1APazE41s8fM7Akz+0ja9VBfVm9crdseu02DWwbHnW5o65Bue+w23b/p/qrVXrxYakvOIbW1hfE0FOuYpVtn7txQQwo/585Np06WtebNG1ln3rx06mT1XpCkvj4pnw+P8/kwDlSSakCbWaukr0h6q6RDJf0PMzs0zZqoL5f/5HINbR2a1LRDW4d0+U8ur0rdxYulr35V2rYtjG/bFsarvWHOqs7cudKmTSPbNm1KJzizqjVvnvTooyPbHn20+iGd1WskhTDu6ZEGBsL4wEAYJ6RRiaV5ytDMjpH0KXd/SzL+UUly989Umr5QKHh/f39q/UF8Zl86e8Kj5xHTt8/Wcx97bsZ129qGN8ilWlulrVtnPPvM6xSPMiup9kc8q1pZ1cnqNZLCEXMxnEt1dUnr11e3FuqHma1x90J5e9o3ic2V9OuS8SclHVXWsR5JPZLU2dmZcncQm6Etkzt6Lnr+xaFxN9wztW3b+MFQb3Wk7OpkWavRXqMNG7Kpg/qSdkBXenuP2Pd1915JvVI4gk65P4hMR3vH1I6gd+7Qc1V4l3AEHX+tZjqC5tgElaR9k9iTkvYvGd9P0qYxpkUTWvCaBWqxyb0NW6xFCw5cUJW6PT1Ta4+9zr77Tq29HmodOsbdKmO1T1dWr5EkLVsm5XIj23K50A6USzug75f0GjM7wMx2knSepFUp10QdWXLMEnW0dUxq2llts7TkmCVVqXvFFdKiReEoSQo/Fy0K7dWUVZ2NG0cH5L77hvZqy6rWI4+MDuNDDw3t1ZTVayRJ3d1Sb2+45mwWfvb2hnagXKo3iUmSmb1N0r9JapX0dXcfc1+Rm8Saj7vr/JXn69Z1t457N3dHW4cWHrxQ1551rSzLi6pVZFb90821rJNlrSyXCcjaWDeJpf530O5+u7sf6O6vHi+c0ZzMTMvPXK6FBy/U7PbZo053t1iLcu05LTx4oZafubxuwxkApopvEkPNtbe269qzrtUPLvyBzj7k7B1BPbt9tt5+6Nt194V365tnf5Ov+QTQVPgubkTBzHTk3CN1/TnX17orABAFjqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMAECECGgCACBHQAABEiIAGACBCBDQAABEioIGUnXSSZBYem4XxNORyI+vkcunUkaR580bWmjcvnTqLF0ttbeFxW1sYB5oFAQ2k6KSTpLvuGtl2113VD+lcThoaGtk2NJROSM+bJz366Mi2Rx+tfkgvXix99avStm1hfNu2ME5Io1mYu9e6DzsUCgXv7++vdTeAqikeZVZSzY9eVnWyrNXWNhzOpVpbpa1bq1cHqDUzW+PuhfL2tlp0BsD4QVePdbKqVSm0gUZEQAM1whH0+MY7ggaaAdeggRSdeOLU2qero2Nq7TNx6KFTa5+unp6ptQONhoAGUnTnnaPD+MQTQ3s1DQ6ODuOOjtBebY88MjqMDz00tFfTFVdIixYNHzG3tobxK66obh0gVtwkBmTErPqnm2tZJ8taWS4TkLWxbhLjCBoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMAECECGgCACKUW0Gb2eTNbZ2YPmtnNZrZHWrUAAGg0aR5Bf1/Sa939dZIel/TRFGsB0TrpJMksPDYL42nYc8+RdfbcM506UnbL1Ncn5fPhcT4fxoFmkVpAu/v33H1rMnqvpP3SqgXE6qSTpLvuGtl2113VD7Q995Sefnpk29NPpxPSWS1TX5/U0yMNDITxgYEwTkijWZi7p1/E7DZJ33L3FeNNVygUvL+/P/X+AFkpHmVWUs2PXlZ1sqyVzw+Hc6muLmn9+urVAWrNzNa4e6G8vW2GM71T0j4Vnlrq7rcm0yyVtFVSxf1eM+uR1CNJnZ2dM+kOUFfGC7p6rJNVrQ0b0q8BxGBGAe3u457UMrMLJZ0m6UQf41Dd3Xsl9UrhCHom/QHqCUfQ4xvrCJr9eDSLNO/iPlXShyWd4e6DadUBYnbiiVNrn6499pha+0xktUzLlkm53Mi2XC60A80gzbu4vyxpV0nfN7Ofmdn/m2ItIEp33jk6uE48MbRX05/+NDqM99gjtFdbVsvU3S319oZrzmbhZ29vaAeaQSY3iU0WN4mhkZlV/3RzLesAqI6xbhLjm8QAAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMAECECGgCACBHQAABEiIAGACBCBDQAABEioAEAiBABDQBAhAhoAAAiRECjafX1Sfm81NISfvb1pVNn8WKprS08bmsL42koLo+U7vIAyEZbrTsA1EJfn9TTIw0OhvGBgTAuSd3d1auzeLH01a8Oj2/bNjx+xRXVq5PV8gDIjrl7rfuwQ6FQ8P7+/lp3A00gnw8hVq6rS1q/vnp12tpCKJdrbZW2bq1enayWB0D1mdkady+Ut3MEjaa0YUPl9oEBySz9+tu2ZVNnrOUEED+uQaMpdXZWbu/qktyrN7S2Vq7T2lrdOl1dU1tOAPEjoNGUli2TcrmRbblcaK+m4nXgybZPV1bLAyA7BDSaUne31Ns7fOTZ1RXGq31D1RVXSIsWDR9Jt7aG8WreICaNXB6z9JYHQHa4SQxNzyycJgaAWhjrJjGOoAEAiBABDQBAhAhoAAAiREADABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIUOoBbWYfNDM3s1ekXQsAgEaRakCb2f6STpa0Ic06wHT09Un5fHicz4dxAIhF2kfQ/yrpQ5I85TrAlPT1ST090sBAGB8YCOOENIBYpBbQZnaGpI3u/vO0agDTtXSpNDg4sm1wMLQDQAzaZvLLZnanpH0qPLVU0scknTKJefRI6pGkzs7OmXQHmLQNY1x0GasdALI2o4B295MqtZvZYZIOkPRzM5Ok/ST91MyOdPffls2jV1KvJBUKBU6FIxOdncOnt8vbASAGqZzidveH3H2Ou+fdPS/pSUmHl4czUCvLlkm53Mi2XC60A0AM+DtoNKXubqm3V+rqCuNdXWG8u7u2/QKAInOP56xyoVDw/v7+WncDTcZMiuhjAKDJmNkady+Ut3MEDQBAhAhoAAAiREADABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQKNp9fVJ+Xx4nM+HcQCIRVutOwDUQl+f1NMjDQ6G8YGBMC5J3d216xcAFHEEjaa0dOlwOBcNDoZ2AIgBAY2mtGHD1NoBIGsENJpSZ+fU2gEgawQ0mtKyZVIuN7ItlwvtABADAhpNqbtb6u2VurrCeFdXGOcGMQCxMHevdR92KBQK3t/fX+tuoMmYSRF9DAA0GTNb4+6F8naOoAEAiBABDQBAhAhoAAAiREADABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECEUg1oM3uPmT1mZo+Y2efSrAUAQCNJLaDN7M2SFkp6nbvPk3RZWrWA6ejrk/L58DifD+MAEIu2FOe9SNJn3f1FSXL3zSnWAqakr0/q6ZEGB8P4wEAYl6Tu7tr1CwCK0jzFfaCkvzaz+8zsR2Y2P8VawJQsXToczkWDg6EdAGIwoyNoM7tT0j4VnlqazHtPSUdLmi/pejN7lbt72Tx6JPVIUmdn50y6A0zahg1TaweArM0ooN39pLGeM7NFklYmgbzazLZLeoWkp8rm0SupV5IKhYKPmhGQgs7OcFq7UjsAxCDNU9y3SDpBkszsQEk7Sfp9ivWASVu2TMrlRrblcqEdAGKQZkB/XdKrzOxhSddJurD89DZQK93dUm+v1NUVxru6wjg3iAGIhcWUmYVCwfv7+2vdDTQZMymijwGAJmNma9y9UN7ON4kBABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMAECECGgCACBHQaFp9fVI+Hx7n82EcAGLRVusOALXQ1yf19EiDg2F8YCCMS1J3d+36BQBFHEGjKS1dOhzORYODoR0AYkBAoylt2DC1dgDIGgGNptTZObV2AMgaAY2mtGyZlMuNbMvlQjsAxICARlPq7pZ6e6WurjDe1RXGuUEMQCzM3Wvdhx0KhYL39/fXuhtoMmZSRB8DAE3GzNa4e6G8nSNoAAAiREADABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMAEKHUAtrM3mBm95rZz8ys38yOTKsWMB19fVI+Hx7n82E8zTotLenWAdBY2lKc9+ckXeLu3zGztyXjx6dYD5i0vj6pp0caHAzjAwNhXJK6u+uvDoDGk+Ypbpe0W/J4d0mbUqwFTMnSpcOhWTQ4GNrrsQ6AxmPuns6MzQ6RdIckU9gR+Et3H6gwXY+kHknq7Ow8YmBg1CRA1bW0SCm99SfFTNq+vXb1AcTDzNa4e6G8fUZH0GZ2p5k9XGFYKGmRpH9y9/0l/ZOkKyvNw9173b3g7oW99tprJt0BJq2zs3J7V1cI7moNXV1Tqw8ARTMKaHc/yd1fW2G4VdKFklYmk94giZvEEI1ly6RcbmRbLhfa67EOgMaT5jXoTZLelDw+QdIvUqwFTEl3t9TbG45wzcLP3t7q37hVWkdKrw6AxpPmNehjJX1R4U7xFyQtdvc14/1OoVDw/v7+VPoD1JpZba97A4jTWNegU/szK3f/T0lHpDV/AAAaGd8kBgBAhAhoAAAiREADABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMp6+uT8vnwOJ8P4wAwkbZadwBoZH19Uk+PNDgYxgcGwrgkdXfXrl8A4scRNJCipUuHw7locDC0A8B4CGggRRs2TK0dAIoIaCBFnZ1TaweAIgIaSNGyZVIuN7ItlwvtADAeAhpIUXe31NsrdXWF8a6uMM4NYgAmYu5e6z7sUCgUvL+/v9bdAFJhJkX0cQMQCTNb4+6F8naOoAEAiBABDQBAhAhoAAAiREADABAhAhoAgAgR0AAARIiABgAgQgQ0AAARIqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENJAWd+m++6RzzpFmz9Y2tUizZ0vnniutXs0/hwYwLgIaSMOWLdL550snnCCtXCkNDqpFLg0OSjfdFNrPPz9MBwAVzCigzewcM3vEzLabWaHsuY+a2RNm9piZvWVm3QTqiLt0wQXSqlUhkLdvH/n89u3S889Lt94apuNIGkAFMz2CfljSWZLuKW00s0MlnSdpnqRTJV1hZq0zrAXUh9WrpdtuC+E8nqGhMN3992fTLwB1ZUYB7e5r3f2xCk8tlHSdu7/o7r+S9ISkI2dSC6gbl18ewncyhobC9ABQJq1r0HMl/bpk/MmkDWh83/726NPaY9m+PUwPAGXaJprAzO6UtE+Fp5a6+61j/VqFtooX2sysR1KPJHV2dk7UHSB+kz16nu70AJrChAHt7idNY75PStq/ZHw/SZvGmH+vpF5JKhQK3C2D+tfRMfH15/LpAaBMWqe4V0k6z8x2NrMDJL1G0uqUagFxWbBAapnkR6ulJUwPAGVm+mdWf2NmT0o6RtK3zewOSXL3RyRdL+lRSd+V9G533zbTzgJ1YcmSyR8Vz5oVpgeAMjO9i/tmd9/P3Xd2973d/S0lzy1z91e7+0Hu/p2ZdxWoE0ceKZ1++sQh3dEhnXGGNH9+Nv0CUFf4JjGg2syk5culhQvDV3uWn+5uaZFyufD88uVhegAoQ0ADaWhvl669VvrBD6Szzx4O6tmzpbe/Xbr7bumb3wzTAUAFE97FDWCazMLp7uuvr3VPANQhjqABAIgQAQ0AQIQIaAAAIkRAAwAQIQIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACJEQAMAECFz91r3YQcze0rSQAalXiHp9xnUyVKjLVOjLY/EMtWDRlseiWWqB13uvld5Y1QBnRUz63f3Qq37UU2NtkyNtjwSy1QPGm15JJapnnGKGwCACBHQAABEqFkDurfWHUhBoy1Toy2PxDLVg0ZbHollqltNeQ0aAIDYNesRNAAAUWv6gDazD5qZm9krat2XmTCzz5vZOjN70MxuNrM9at2n6TKzU83sMTN7wsw+Uuv+zJSZ7W9mPzSztWb2iJm9r9Z9qgYzazWzB8zsP2rdl2owsz3M7Mbkc7TWzI6pdZ9mysz+KXnPPWxm3zSzWbXu01SZ2dfNbLOZPVzS9jIz+76Z/SL5uWct+5iWpg5oM9tf0smSNtS6L1XwfUmvdffXSXpc0kdr3J9pMbNWSV+R9FZJh0r6H2Z2aG17NWNbJS1x90MkHS3p3Q2wTJL0Pklra92JKvqipO+6+8GSXq86XzYzmyvpvZIK7v5aSa2Szqttr6blKkmnlrV9RNJd7v4aSXcl4w2nqQNa0r9K+pCkur8Q7+7fc/etyei9kvarZX9m4EhJT7j7L939JUnXSVpY4z7NiLv/xt1/mjz+s8KGf25tezUzZrafpAWSvlbrvlSDme0m6ThJV0qSu7/k7k/XtFPV0Sapw8zaJOUkbapxf6bM3e+R9Mey5oWSrk4eXy3pzCz7lJWmDWgzO0PSRnf/ea37koK/l/SdWndimuZK+nXJ+JOq8zArZWZ5SW+UdF+NuzJT/6awc7u9xv2olldJekrSN5LT9l8zs9m17tRMuPtGSZcpnCH8jaRn3P17te1V1ezt7r+Rwg6wpDk17k8qGjqgzezO5NpL+bBQ0lJJn6h1H6diguUpTrNU4ZRqX+16OiNWoa3uz3BIkpntIukmSe9392dr3Z/pMrPTJG129zW17ksVtUk6XNJX3f2Nkp5XnZ82Ta7LLpR0gKR9Jc02s3fUtleYirZadyBN7n5SpXYzO0zhTftzM5PC6eCfmtmR7v7bDLs4JWMtT5GZXSjpNEknev3+/dyTkvYvGd9PdXharpyZtSuEc5+7r6x1f2borySdYWZvkzRL0m5mtsLd63nj/6SkJ929eGbjRtV5QEs6SdKv3P0pSTKzlZL+UtKKmvaqOn5nZq9099+Y2Sslba51h9LQ0EfQY3H3h9x9jrvn3T2v8OE8POZwnoiZnSrpw5LOcPfBWvdnBu6X9BozO8DMdlK4qWVVjfs0Ixb2Aq+UtNbdv1Dr/syUu3/U3fdLPjvnSfpBnYezks/+r83soKTpREmP1rBL1bBB0tFmlkvegyeqzm98K7FK0oXJ4wsl3VrDvqSmoY+gm8yXJe0s6fvJWYF73f1/17ZLU+fuW83sHyXdoXDX6dfd/ZEad2um/krS/5T0kJn9LGn7mLvfXrsuoYL3SOpLdgx/KenvatyfGXH3+8zsRkk/Vbjs9YDq8Bu4zOybko6X9Aoze1LSJyV9VtL1ZvYuhR2Rc2rXw/TwTWIAAESoKU9xAwAQOwIaAIAIEdAAAESIgAYAIEIENAAAESKgAQCIEAENAECECGgAACL0/wOYLQhQHsaOKgAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 576x576 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "x, y = 0, 0\n",
    "X, Y = [x], [y]\n",
    "prevpos = [(0,0)]\n",
    "steps=0\n",
    "for i in range(n):\n",
    "    deltas = [(1,0), (0,1), (-1,0), (0,-1)] #these are the increments\n",
    "    deltas_feasible = [] #these store the list with all the feasible increments for step i\n",
    "    for dx, dy in deltas:\n",
    "        if (X[-1] + dx, Y[-1] + dy) not in prevpos:  \n",
    "            deltas_feasible.append((dx,dy))\n",
    "    dx, dy = deltas_feasible[randint(0,len(deltas_feasible))]\n",
    "    X.append(X[-1] + dx)\n",
    "    Y.append(Y[-1] + dy)\n",
    "    prevpos = [(X[-2], Y[-2])]\n",
    "    steps+=1\n",
    "\n",
    "plt.figure(figsize = (8, 8))\n",
    "plt.plot(X, Y, 'bo-', linewidth = 1)\n",
    "plt.plot(0, 0, 'go', ms = 12, label = 'Start')\n",
    "plt.plot(X[-1], Y[-1], 'ro', ms = 12, label = 'End')\n",
    "plt.axis('equal')\n",
    "plt.legend(fontsize=15)\n",
    "plt.title('Figure 3: Non-reversing RW of length ' + str(steps), fontsize=14, fontweight='bold')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Avoiding Oneself: The Rosenbluth Self-Avoiding Walk"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We shall now proceed to the meat of our presentation - a **self-avoiding walk**. In simplest terms, it is a random walk that never intersects itself. Our task is the same as that for the famous mobile game *Snake* - the moment the snake bites itself, we are done. [Note: There are more things to be taken into account regarding the ergodicity of our distribution of SAWs and their relative prevalence within that distribution, but we shall come to this later.]\n",
    "\n",
    "The self-avoiding walk is an extremely good model for **linear long-chain polymers in a good solvent** - technically, we can say that the two problems belong in the same **universality class**, as has been rigorously proved by EW Montroll in 1950 and Mark Fisher in 1974 in a modern renormalization group paradigm. As such, figuring out a way to simulate SAWs effectively can help us understand polymer conformations. Considering polymers lie at the heart of almost all of biology and industrial chemistry, this problem is clearly well-motivated. \n",
    "\n",
    "As should be clear here, in this case, our walker needs to remember not just the immediately previous point, but all the points it has visited. A simple algorithm for how to simulate this was given by **Marshall and Arianna Rosenbluth** in 1955, and it goes as follows:\n",
    "\n",
    "> Set the origin as the starting vertex, and recursively choose the next vertex from the set of nearest neighbors that are not occupied by the walk. If there are no nearest neighbors available, then the walk is rejected and a new walk is initiated at the origin.\n",
    "\n",
    "This is similar to what we did for non-reversing random walks, but now we need to store all the previous positions in our memory. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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4LxZYSfxPHf/913n3Hxs53cORis5fTi1suKb2SRJtyocuTwvaT+nw9Fikr9IdYkkufuEuokmptj9amYHSnqq8p1mZu/Wzh3xC929s9E1NRtuwhpbB0haltxJ+muFm3qKyXNfInwBTCDfkDTLzB5WuLb8B0n7KoUzFhgEp6DH1gaF024HKZwS2kvhr9jMcfeF0aoCgLF3p8JlgZMUThWvkfRNhfsDBvsVNohT0AAARMERMAAAERDAAABEQAADABABAQwAQAQEMAAAERDAAABEQAADABABAQwAQAQEMAAAERDAAABEQAADABABAQwAQAQEMAAAERDAAABEQAADABABAQwAQAQEMAAAERDAAABEQAADABABAQwAQAQEMAAAERDAAABEQAADABABAQwAQASTG7mw6dOne7FYbOQiAQCIZuXKlb929xnVnmtoABeLRZXL5UYuEgCAaMysu9ZznIIGACACAhgAgAgIYAAAImjoNeBqtm7dqnXr1mnz5s2xSxl3U6dO1cyZMzVlypTYpQAAIosewOvWrdOee+6pYrEoM4tdzrhxd23cuFHr1q3TAQccELscAEBk0U9Bb968Wfvss8+g4evuWrZumc68+ky1fa1Nuctyavtam866+iwtf2653L1BFY+MmWmfffZpiSN9AMDgoh8BSxo0fLdu36rzrz9fNzx+gzZv26w+75Mk9Wzt0bWrrtUtT96iD73tQ1p06iJNmZTd07sT+QgfADA80Y+AB+PuO8K3Z2vPjvCt6PM+bdq6SUtXL9X5158/4iPhBQsW6LDDDtORRx6pWbNmadmyZfrWt76lnp6eYc9r4cKFWr9+/YjqAAC0hswH8PLnluvGx29Uz9b6Qdi7rVc3Pn6jVqxfMexl3Hvvvbrpppt0//3366GHHtJPf/pT7b///iMK4O3btxPAAIBBZT6Ar7j3CvVu6x3StL3benXFvVcMexnPP/+8pk+frt13312SNH36dF1zzTVav369TjzxRJ144omSpIsuukilUkmHHXaYLrnkkh2vLxaL+spXvqITTjhBS5YsUblc1rx58zRr1iz19g6tdgBAa8l8AN/85M27nHaupc/7dPMTNw97GSeffLKeffZZHXTQQfrkJz+pu+++W5/5zGf05je/WXfeeafuvPNOSeE0dblc1kMPPaS7775bDz300I55TJ06VT//+c913nnn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\n",
      "text/plain": [
       "<Figure size 576x576 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "def rosenbluth_saw(n):\n",
    "    x, y = [0], [0]\n",
    "    positions = [(0,0)]  #positions is a list that stores all sites visited by the walk\n",
    "    stuck = 0 #stuck is a Boolean variable that records if we are able to find an SAW of required length, or get stuck\n",
    "    for i in range(n):\n",
    "        deltas = [(1,0), (0,1), (-1,0), (0,-1)]\n",
    "        deltas_feasible = []  #deltas_feasible stores the available directions \n",
    "        for dx, dy in deltas:\n",
    "            if (x[-1] + dx, y[-1] + dy) not in positions:  #checks if direction leads to a site not visited before\n",
    "                deltas_feasible.append((dx,dy))\n",
    "        if deltas_feasible:  #checks if there is a direction available\n",
    "            dx, dy = deltas_feasible[np.random.randint(0,len(deltas_feasible))]  #choose a direction at random among available ones\n",
    "            positions.append((x[-1] + dx, y[-1] + dy))\n",
    "            x.append(x[-1] + dx)\n",
    "            y.append(y[-1] + dy)\n",
    "        else:  #in that case the walk is stuck\n",
    "            stuck = 1\n",
    "            steps = i+1\n",
    "            break  #terminate the walk prematurely\n",
    "        steps = n+1\n",
    "    return x, y, stuck, steps\n",
    "\n",
    "n=80\n",
    "x, y, stuck, steps = rosenbluth_saw(n)\n",
    "plt.figure(figsize = (8, 8))\n",
    "plt.plot(x, y, 'bo-', linewidth = 1)\n",
    "plt.plot(0, 0, 'go', ms = 12, label = 'Start')\n",
    "plt.plot(x[-1], y[-1], 'ro', ms = 12, label = 'End')\n",
    "plt.axis('equal')\n",
    "plt.legend()\n",
    "if stuck:\n",
    "    plt.title('Figure 4: Walk stuck at step ' + str(steps) + ' attempting ' + str(n), fontsize=14, fontweight='bold', y = 1.05)\n",
    "else:\n",
    "    plt.title('Figure 4: SAW of length ' + str(n), fontsize=14, fontweight='bold', y = 1.05)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see, this is not a rock-solid approach - there will be many iterations when we are not able to generate a self-avoiding walk of the required length. This is especially a problem in $2D$ and gets compounded exponentially as we go to longer and longer lengths. In fact, if we had done a simple rejection sampling of SAWs from a distribution of RWs, like we did first for the non-reversing walk, we would find that for $n=20$, only about one in $1200$ would be a self-avoiding walk. For $n=50$, that falls to about one in $24,000,000,00$ (240 million). (Thankfully, we didn't take this approach!) Imagine what would happen if we try and simulate SAWs of lengths $n\\approx 3000$, which is the length of a polyethylene chain. But how much better does our Rosenbluth algorithm fare? Let us find out!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "e0=time.time() #this measures when the process for this cell starts\n",
    "def is_saw(x, y, n):\n",
    "    return n+1 == len(set(zip(x,y)))  #creating a set removes duplicates, so it suffices to check the size of the set\n",
    "def rejection_sampling(n, samples):\n",
    "    accepted = 0\n",
    "    for i in range(samples):\n",
    "        x, y, _, _ = rosenbluth_saw(n) #generates a Rosenbluth SAW\n",
    "        if is_saw(x, y, n): #checks if it is a SAW\n",
    "            accepted += 1\n",
    "    return accepted/samples\n",
    "\n",
    "def plot_acceptance(n, samples):\n",
    "    acceptance = []\n",
    "    n_list = [5, 10, 15, 20, 25, 30, 35, 40, 45]\n",
    "    for i in range(1, n):\n",
    "        acceptance.append(rejection_sampling(i, samples)*100)\n",
    "    plt.figure(figsize = (8, 8))\n",
    "    plt.plot(range(1, n), acceptance, 'o-')\n",
    "    plt.grid(True)\n",
    "    ax = plt.axes()\n",
    "    ax.set_xticks(n_list)\n",
    "    ax.yaxis.set_major_formatter(PercentFormatter())\n",
    "    plt.title('Figure 5: Acceptance rate of the rejection sampling method, for Rosenbluth SAWs of different n', \n",
    "              fontsize=14, fontweight='bold', y = 1.05)\n",
    "    plt.show()\n",
    "\n",
    "plot_acceptance(50,10000)\n",
    "elapsed_time=time.time()-e0\n",
    "print(\"The time taken to generate this plot is\", elapsed_time, \" seconds.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see, this graph tells us the Rosenbluth algorithm has pretty good acceptance rates for small $n\\approx 20$ - however, the trend of the graph suggests this will fall away as we go up to 100-300, as it is already at $60$ percent for $n=50$. On running this program for $n=150-300$, the times taken were prohibitively long and computing power required was too high for a low-end laptop - so we have kept it to $n=50$ here, which itself took close to 2 minutes. \n",
    "\n",
    "However, for small $n$, we see that the algorithm will be able to generate an SAW on the vast majority of its iterations. This is in stark contrast to the same program for simple random walks left to generate SAWs by chance, where we shall see the acceptance rate falls away exponentially even for $n\\approx 20$. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def simple_RW(n): #generates a random walk by the simple algorithm we used at the beginning\n",
    "    x, y = [0], [0]\n",
    "    deltas = [(1,0), (0,1), (-1,0), (0,-1)] #possible directions for the 2D lattice\n",
    "    for _ in range(n):\n",
    "        dx, dy = deltas[np.random.randint(0,4)]   #direction chosen at random\n",
    "        x.append(x[-1] + dx)\n",
    "        y.append(y[-1] + dy)\n",
    "    return x, y\n",
    "\n",
    "def rejection_sampling_simple(n, samples):\n",
    "    accepted = 0\n",
    "    for i in range(samples):\n",
    "        x, y= simple_RW(n) #generates a Rosenbluth SAW\n",
    "        if is_saw(x, y, n): #checks if it is a SAW\n",
    "            accepted += 1\n",
    "    return accepted/samples\n",
    "\n",
    "def plot_acceptance(n, samples):\n",
    "    acceptance = []\n",
    "    for i in range(1, n):\n",
    "        acceptance.append(rejection_sampling_simple(i, samples)*100)\n",
    "    plt.figure(figsize = (8, 8))\n",
    "    plt.plot(range(1, n), acceptance, 'o-')\n",
    "    plt.grid(True)\n",
    "    ax = plt.axes()\n",
    "    ax.set_xticks(list(range(1,n)))\n",
    "    ax.yaxis.set_major_formatter(PercentFormatter())\n",
    "    plt.title('Figure 6: Acceptance rate of the rejection sampling method, for simple RWs of different n', \n",
    "              fontsize=14, fontweight='bold', y = 1.05)\n",
    "    plt.show()\n",
    "\n",
    "plot_acceptance(20,10000)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A Short Note on Paul Flory, father of polymers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Much of the most influential theoretical work on polymers was done by **Paul Flory**, who used an ingenious combination of dimensional arguments, physical intuition and field theoretic calculations to show that the mean squared end-to-end distance for a polymer (or SAW) varies as\n",
    "\\begin{equation}\n",
    "    R\\propto N^{3/(d+2)},\n",
    "\\end{equation}\n",
    "where $d$ is the naive dimension (NOT the fractal dimension) of the polymer being studied. In our case $d=2$, so we get the relation, \n",
    "\\begin{equation}\n",
    "    R^2\\propto N^{3/2}\n",
    "\\end{equation}\n",
    "As we can see, self-avoiding walks stretch out more than simple random walks (which had a $R^2\\propto N$ relation), on average - this is called the excluded volume effect, and we should expect this! After all, simple random walks can twist over and into themselves and curl up much tighter than a self-avoiding walk, which can never intersect itself - in fact, in some polymers, there is a repulsion effect between non-adjacent monomer units, which further contributes to stretching out. Especially in a good solvent, the monomer units prefer to associate with solvent molecules more than other monomer units, which can further facilitate this stretching out.\n",
    "\n",
    "Flory won a Nobel Prize in 1974 for his work in this field, and his Nobel lecture on **\"Spatial Configuration of Macromolecular Chains\"** is worth reading for those interested in polymer science. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## First Among Equals: A Challenge for Computational Estimation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "All well and good. But since we seem to have a fairly decent algorithm to generate SAWs, can we now start to computationally estimate global quantities associated with SAWs, and by extension, polymers? Not so fast. In our discussion, we have conveniently assumed that all SAWs are created equal, whereas in reality, they are not! Different SAWs have different probabilities of occurrence, depending on their geometry. Let us see how.\n",
    "\n",
    "<img src=https://i.imgur.com/p3GqPeL.png width=\"600\">\n",
    "\n",
    "Consider the two 4-step SAWs shown above. What are their probabilities of occurrence?\n",
    "\n",
    "For the first one, when it starts, it has four possible directions to move in - so probability for first step=$\\frac{1}{4}$. The next step can move in any direction but backward, so probability for second step=$\\frac{1}{3}$. Same for third step = $\\frac{1}{3}$. But for fourth step, it only has two directions to go in, left or up, without intersections, so probability =$\\frac{1}{2}$ - so total probability for this walk is $P_1=\\frac{1}{4}\\frac{1}{3}\\frac{1}{3}\\frac{1}{2}$.\n",
    "\n",
    "For the second one, when it starts, as usual, it has four steps to choose from, so probability of first step=$\\frac{1}{4}$. But for all the subsequent steps along the straight line, the walker will always have three options to choose from, i.e. any direction but backward, so probability for 2nd to 4th steps, probability=$\\frac{1}{3}$, so total probability $P_2=\\frac{1}{4}\\frac{1}{3}\\frac{1}{3}\\frac{1}{3}$. \n",
    "\n",
    "As we can see, $P_2>P_1$, in fact the second walk is $1.5$ times as likely to occur if we run a program as the first one. So based on this, we can assign a weight $W_i=1/P_i$ for every SAW, and when we compute any quantity, e.g. $R^2$, we have to make sure to compute a weighted average, or what is called **importance sampling**. \n",
    "\n",
    "In the following program, we shall try to simulate $N=1000$ samples for a range of SAW of lengths going from $n=2,20$, compute the mean squared end-to-end distance, and compare the relative error with the standard values found from the literature. \n",
    "\n",
    "[Note: We have started $n$ from 2 because you need at least 2 points to have 1 step, i.e. a walk.]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def saw_weights(n):\n",
    "    x, y = [0], [0] \n",
    "    positions = [(0,0)]\n",
    "    weights = []\n",
    "    stuck = 0\n",
    "    for i in range(n):\n",
    "        deltas = [(1,0), (0,1), (-1,0), (0,-1)]\n",
    "        deltas_feasible = []\n",
    "        for dx, dy in deltas:\n",
    "            if (x[-1] + dx, y[-1] + dy) not in positions:\n",
    "                deltas_feasible.append((dx,dy))\n",
    "        if deltas_feasible:\n",
    "            weights.append(len(deltas_feasible))  #add inverse probability to weights\n",
    "            dx, dy = deltas_feasible[randint(0,len(deltas_feasible))]\n",
    "            positions.append((x[-1] + dx, y[-1] + dy))\n",
    "            x.append(x[-1] + dx)\n",
    "            y.append(y[-1] + dy)\n",
    "        else:\n",
    "            stuck = 1\n",
    "            break\n",
    "    return x, y, stuck, weights\n",
    "\n",
    "def importance_sampling(n, samples):\n",
    "    saw = 0\n",
    "    weight_list = []  #stores weight of each SAW\n",
    "    norm_list = []  #stores squared end-to-end distance of each SAW\n",
    "    while saw < samples:  \n",
    "        x, y, stuck, weights = saw_weights(n)\n",
    "        weights=np.array(weights)\n",
    "        if not stuck:\n",
    "            weight_list.append(np.prod(weights))  #computes final weight of the walk as product of its weights\n",
    "            norm_list.append(x[-1]**2 + y[-1]**2)  #computes squared end-to-end distance\n",
    "            saw += 1\n",
    "    weight_list = np.array(weight_list)\n",
    "    norm_list = np.array(norm_list)\n",
    "    estim = np.sum(weight_list * norm_list) / np.sum(weight_list)  #computes estimate (vectorized)\n",
    "    std = np.sqrt(np.sum( (weight_list / np.sum(weight_list))**2 * (norm_list - estim)**2 )) #computes std (vectorized)\n",
    "    return (estim, std) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "e0=time.time()\n",
    "sq_dis = [2.66667,4.55556,7.04,9.56338,12.5744,15.5562,19.0128,22.4114,26.2425,30.0177,34.187,38.3043,42.7864,\n",
    "          47.2177,51.9925,56.7164,61.7665,66.7658,72.0765] # hardcoded list of exact mean-squared distances obtained from the literature\n",
    "sq_dis=np.array(sq_dis)\n",
    "rsq = []\n",
    "relative_error= []\n",
    "for i in range(19):\n",
    "    estim, _ = importance_sampling(i+2, 1000)\n",
    "    rsq.append(estim)\n",
    "    relative_error.append(abs(estim-sq_dis[i])/sq_dis[i]*100)\n",
    "plt.figure(figsize = (8, 8))\n",
    "plt.plot(range(2, 21), relative_error, 'o-')\n",
    "plt.grid(True)\n",
    "ax = plt.axes()\n",
    "ax.set_xticks(list(range(2,21)))\n",
    "ax.yaxis.set_major_formatter(PercentFormatter())\n",
    "plt.title('Figure 7: Relative errors of the estimate of the squared end-to-end distance, for different n', \n",
    "              fontsize=14, fontweight='bold', y = 1.05)\n",
    "plt.show()\n",
    "elapsed_time=time.time()-e0\n",
    "print(\"The time taken to generated this plot is\", elapsed_time, \"seconds\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This is not at all what we should expect. For $n>10$, we see a sharp spike in the relative error - it has been suggested in the literature that this kind of instability exists in the Rosenbluth algorithm, and that we may need significantly greater processing power to be able to generate enough samples for this to be a useful computational estimate. For $n=10$, there are about the order of $10^7$ unique walks - for $n=11$, this jumps up to $10^8$, and maybe $N=10^3$ may no longer be good enough to get an accurate idea of estimates over the whole sample space. However, at least we see that upto $n=10$, this gives us good correlation with the expected mean squared end-to-end distances. \n",
    "\n",
    "To end this exploration, we end with two plots, one for the walks we generated from $n=(2,10)$ and one for the curve $R=N^{3/2}$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x=np.linspace(2,9,num=8)\n",
    "plt.plot(x, rsq[1:9])\n",
    "plt.plot(x, x**1.5)\n",
    "plt.legend([\"Computed Estimate of R^2\", \"R^2=N^(3/2)\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Animation\n",
    "\n",
    "%matplotlib notebook\n",
    "import celluloid\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.pylab as pl\n",
    "import numpy as np\n",
    "import numba\n",
    "from numba import jit, njit\n",
    "from celluloid import Camera\n",
    "import ffmpeg\n",
    "from numpy.random import randint, random, choice\n",
    "from IPython.display import HTML\n",
    "from matplotlib.colors import LogNorm\n",
    "from matplotlib import cm\n",
    "\n",
    "np.random.seed(0)\n",
    "n=100\n",
    "fig=plt.figure(figsize=(8, 8))\n",
    "camera = Camera(fig)\n",
    "\n",
    "x, y = [0], [0]\n",
    "positions = [(0,0)]  #positions is a list that stores all sites visited by the walk\n",
    "for i in range(n):\n",
    "    deltas = [(1,0), (0,1), (-1,0), (0,-1)]\n",
    "    deltas_feasible = []  #deltas_feasible stores the available directions \n",
    "    for dx, dy in deltas:\n",
    "        if (x[-1] + dx, y[-1] + dy) not in positions:  #checks if direction leads to a site not visited before\n",
    "            deltas_feasible.append((dx,dy))\n",
    "    if deltas_feasible:  #checks if there is a direction available\n",
    "        dx, dy = deltas_feasible[randint(0,len(deltas_feasible))]  #choose a direction at random among available ones\n",
    "        positions.append((x[-1] + dx, y[-1] + dy))\n",
    "        x.append(x[-1] + dx)\n",
    "        y.append(y[-1] + dy)\n",
    "    else:  #in that case the walk is stuck\n",
    "        break  #terminate the walk prematurely\n",
    "    plt.plot(x, y, 'bo-', linewidth = 1)\n",
    "    plt.plot(0, 0, 'go', ms = 12)\n",
    "    plt.plot(x[-1], y[-1], 'ro', ms = 12)\n",
    "    plt.xlim(min(x)-1, max(x)+1)\n",
    "    plt.ylim(min(y)-1, max(y)+1)\n",
    "    plt.axis('equal')\n",
    "    camera.snap()\n",
    "\n",
    "animation = camera.animate()\n",
    "animation.save('SAW_anim.mp4')\n",
    "HTML(animation.to_html5_video())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
